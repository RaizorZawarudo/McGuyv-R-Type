/*
** EPITECH PROJECT, 2023
** MCGUYVER-TYPE_EPITECH
** File description:
** DataReceivingSystem
*/

#include "DataReceivingSystem.hpp"


DataReceivingSystem::DataReceivingSystem(std::shared_ptr<EntityManager> em, std::shared_ptr<AssetManager> assetManager, std::shared_ptr<RL::InputManager> inputManager, std::shared_ptr<RL::MenuManager> _menuManager, std::shared_ptr<UDPClient> udpClient): _assetManager(assetManager), _inputManager(inputManager), _menuManager(_menuManager), _udpClient(udpClient) //add deserialiser to constructor
{
    _em = em;

}

DataReceivingSystem::~DataReceivingSystem() {};

void DataReceivingSystem::applyNewPosition(EntityID id, int x, int y, int z, int pitch, int yaw, int roll)
{
    _em->Get<Position>(id)->pos.x = x;
    _em->Get<Position>(id)->pos.y = y;
    _em->Get<Position>(id)->pos.z = z;
    _em->Get<PitchYawRoll>(id)->pitch = pitch;
    _em->Get<PitchYawRoll>(id)->yaw = yaw;
    _em->Get<PitchYawRoll>(id)->roll = roll;
}


void DataReceivingSystem::update(std::vector<EntityID> &allEntities)
{
    std::vector<boost::array<char, 1024UL>> packets = _udpClient->getMessages();

    if (!_createdplayer) {
        _createdplayer = true;
        createPlayerClient(_menuManager->getCharacterName() , 0, _assetManager->getCurrentClientID());
    }
    for (auto packet : packets) {
        Msg msg = _serializator.bytesToStruct(packet.data());
        for (EntityID _ent:  EntityViewer<ServerEntityID>(*_em.get())) {
            if (_em->Get<ServerEntityID>(_ent)->id == msg.getId() && _em->Get<EntityModelType>(_ent)->modelType == RL::ModelType::ENNEMY) {
                applyNewPosition(_ent, msg.getX(), msg.getY(), msg.getZ(), msg.getPitch(), msg.getYaw(), msg.getRoll());
                return;
            }
            if (_em->Get<ServerEntityID>(_ent)->id == msg.getId() && _em->Get<EntityModelType>(_ent)->modelType == RL::ModelType::SPACESHIP) {
                applyNewPosition(_ent, msg.getX(), msg.getY(), msg.getZ(), msg.getPitch(), msg.getYaw(), msg.getRoll());
                return;
            }
        }
        switch (msg.getstatus()) {
            case serializator::Header::UpdateObstacle:
                createObstacleClient(_assetManager->getObstacleModels().at(msg.getObstacleIndex())->getName(), (Vector3){msg.getX(), msg.getY(), msg.getZ()}, msg.getId());//5678 is a random entity ID generated by serever
                break;
            case serializator::Header::UpdateEnnemy:
                std::cout << "CREATE ENNEMY" << std::endl;
                createEnnemyClient(_assetManager->getEnnemyModels().at(msg.getEnemyIndex())->getName(), (Vector3){msg.getX(), msg.getY(), msg.getZ()}, msg.getId());
                break;
            case serializator::Header::UpdateLoot:
                create_lootClient((Vector3){msg.getX(), msg.getY(), msg.getZ()}, _assetManager->getPowerUpModels().at(msg.getLootIndex())->getName(),msg.getId());
                break;
            case serializator::Header::UpdateExplosion:
                create_explosion((Vector3){msg.getX(), msg.getY(), msg.getZ()}, _assetManager->getExplosionModels().at(msg.getExplosionIndex())->getName(), msg.getId());
                break;
            case serializator::Header::UpdateProjectile:
                createProjectileClient((Vector3){msg.getX(), msg.getY(), msg.getZ()}, msg.getWeaponId(), msg.getOwnerId(), msg.getDirection(), msg.getId());
                break;
            case serializator::Header::stateGame:
                msg.getstate() ? _assetManager->getMaps().at(_assetManager->getCurrentMapBeingPlayed())->setFightingBossTrue() : _assetManager->getMaps().at(_assetManager->getCurrentMapBeingPlayed())->bossIsDown();
                break;
            case serializator::Header::UpdatePlayer:
                for (EntityID _ent:  EntityViewer<ServerEntityID>(*_em.get())) {
                    if (_em->Get<ServerEntityID>(_ent)->id == msg.getId() && _em->Get<EntityModelType>(_ent)->modelType == RL::ModelType::SPACESHIP) {
                        applyNewPosition(_ent, msg.getX(), msg.getY(), msg.getZ(), msg.getPitch(), msg.getYaw(), msg.getRoll());
                        return;
                    }
                }
                createPlayerClient(_menuManager->getCharacterName() , msg.getId(), _assetManager->getCurrentClientID());
                break;
        }
    }
    _keysPressed = _inputManager->getInputs();


    // for (EntityID ent : EntityViewer<AI>(*_em.get())) {
    // }
}


void DataReceivingSystem::createObstacleClient(std::string modelName, Vector3 position, unsigned long long ID)
{
    EntityID id = _em->CreateNewEntity(); // this causes the segfault, check when i delete entities that i do it properly

    float scrollspeed;

    _em->Assign<EntityModelType>(id, EntityModelType{RL::ModelType::OBSTACLE});
    
    _em->Assign<Owner>(id, Owner{_assetManager->getCurrentClientID(), RL::ModelType::ENNEMY}); //HERE THE VALUE 100000 SHOULD BE THE ID OF THE SERVER NOW SINCE WE MAKE THE GAME IN SERVER


    _em->Assign<Loot>(id, Loot{true});

    
    _em->Assign<ModelName>(id, ModelName{modelName, _assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::OBSTACLE)->getExplosionName()});

    _em->Assign<ModelScale>(id, ModelScale{1.0f});

    
    _em->Assign<ModelDimensions>(id, ModelDimensions{_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::OBSTACLE)->getWidth(),
                                                                _assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::OBSTACLE)->getHeight(),
                                                                _assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::OBSTACLE)->getLength()});

    _em->Assign<PitchYawRoll>(id, PitchYawRoll{0.0f, 0.0f, 0.0f});

    _em->Assign<Collider>(id, Collider{BoundingBox{}});

    
    _em->Assign<IsAlive>(id, IsAlive{true});
    _em->Assign<Position>(id, Position{position});
    scrollspeed = _assetManager->getMaps().at(_assetManager->getCurrentMapBeingPlayed())->getScrollSpeed();
    _em->Assign<Velocity>(id, Velocity{scrollspeed, scrollspeed, scrollspeed});
    _em->Assign<Hp>(id, Hp{_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::OBSTACLE)->getHp()});
    _em->Assign<ServerEntityID>(id, ServerEntityID{ID});
}

void DataReceivingSystem::createEnnemyClient(std::string modelName, Vector3 ennemyPos, unsigned long long ID) // here we will add base weapon choice, avatar choice as well chosen by user in menu, the avatar is just cosmetic
{
    EntityID id = _em->CreateNewEntity();
    //register this entity as the player for this client
    std::vector<int> ennemyInput;
    Vector3 Vel;
    
    float scrollspeed;
    _em->Assign<ServerEntityID>(id, ServerEntityID{ID});

    _em->Assign<EntityModelType>(id, EntityModelType{RL::ModelType::ENNEMY});
    
    _em->Assign<Owner>(id, Owner{_assetManager->getCurrentClientID(), RL::ModelType::ENNEMY}); //here we use 100000 but its the id of the server same as before
    
    _em->Assign<IsAlive>(id, IsAlive{true});    
    
    _em->Assign<ModelName>(id, ModelName{modelName, _assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::ENNEMY)->getExplosionName()});
    _em->Assign<ModelScale>(id, ModelScale{1.0f});

    _em->Assign<Loot>(id, Loot{true});   
    
    _em->Assign<Position>(id,Position{ennemyPos});
    
    _em->Assign<PitchYawRoll>(id, PitchYawRoll{0.0f, 0.0f, 0.0f});
    _em->Assign<ModelDimensions>(id, ModelDimensions{_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::ENNEMY)->getWidth(),
                                                                _assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::ENNEMY)->getHeight(),
                                                                _assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::ENNEMY)->getLength()});
    _em->Assign<Collider>(id, Collider{BoundingBox{}});
    
    scrollspeed = _assetManager->getMaps().at(_assetManager->getCurrentMapBeingPlayed())->getCurrentSpeed();
    _em->Assign<Velocity>(id, Velocity{scrollspeed, scrollspeed, scrollspeed});
    _em->Assign<Hp>(id, Hp{_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::ENNEMY)->getHp()});

    // _em->Assign<AI>(id, AI{_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::ENNEMY)->getStyle()});
    _em->Assign<AI>(id, assignAI(_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::ENNEMY)->getStyle(), id));
    _em->Assign<Input>(id, Input{ennemyInput});
    _em->Assign<Shield>(id, Shield{100});
    //add weaponset to mobs so that they can pickup weapons
    _em->Assign<Weaponset>(id, Weaponset{generateStartWeaponsetEnnemies("fireball"), 0}); //add this to ennemies CSV and update asset manager to reflect weaponset name in the drawable3D


    //try to add animations to bosses only
    _em->Assign<AnimationData>(id, AnimationData{0, 0});
    if (_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::ENNEMY)->getStyle() == "boss")
        _em->Assign<EnnemyAnim>(id, EnnemyAnim{true});
    else
        _em->Assign<EnnemyAnim>(id, EnnemyAnim{false});
    _em->Assign<ServerEntityID>(id, ServerEntityID{ID});
}

std::vector<ProjectileWeapon> DataReceivingSystem::generateStartWeaponsetEnnemies(std::string modelName)
{
    std::vector<ProjectileWeapon> startWeaponset;

    ProjectileWeapon BaseWeapon;
    Vector3 Vel;

    BaseWeapon.name = modelName;
    BaseWeapon.modelName = modelName;
    BaseWeapon.maxAmmo = -999; // unlimitted ammo stock
    BaseWeapon.curAmmo = -999; // unlimitted ammo, both the -999 are for unlimited should define it later
    BaseWeapon.splash = 0.0f; //TODO : add in projectile CSV and in drawable 3d class and constructor and in asset manager loadProjectiles models
    BaseWeapon.range = 50.0f; // TODO: same as above
    BaseWeapon.cooldowninseconds = _assetManager->getSpecificDrawableWithType(BaseWeapon.modelName, RL::ModelType::PROJECTILE)->getShootCD();
    BaseWeapon.damage = _assetManager->getSpecificDrawableWithType(BaseWeapon.modelName, RL::ModelType::PROJECTILE)->getHp();
    Vel = _assetManager->getSpecificDrawableWithType(BaseWeapon.modelName, RL::ModelType::PROJECTILE)->getVelocity();
    BaseWeapon.vel = {Vel.x, Vel.y, Vel.z};
    BaseWeapon.lasttimeweaponwasshot = std::chrono::system_clock::now();
    startWeaponset.push_back(BaseWeapon);
    return startWeaponset;
}

AI DataReceivingSystem::assignAI(std::string AIType, EntityID ennemy)
{
    if (AIType == "simple")
        return assignSimpleAI(AIType, ennemy);
    // if (AIType == "anythingelse")
    //     return assignSimpleAI(AIType, ennemy);
    if (AIType == "boss")
        return assignSimpleAI(AIType, ennemy); //here add AI of specific boss also
    
    //else
    //  return a simpleaie
}

AI DataReceivingSystem::assignSimpleAI(std::string AIType, EntityID ennemy)
{
    AI newAI;

    newAI.style = AIType;
    newAI.isMoving = false;
    newAI.moveCooldown = SIMPLEAIMOVECOOLDOWN;
    newAI.lastTimeMoved = std::chrono::system_clock::now();
    newAI.moveDetectRange = SIMPLEAIMOVEDETECTRANGE;
    newAI.targetPlayerDetectRange = SIMPLEAITARGETPLAYERDETECTRANGE;
    newAI.moveRange = SIMPLEMOVERANGE;
    newAI.moveTargetPos = {0,0,0};

    newAI.hasShot = false;
    newAI.lastTimeShot = std::chrono::system_clock::now();
    newAI.shootCooldown = SIMPLEAISHOOTCOOLDOWN;
    newAI.shootDetectRange = SIMPLEAISHOOTDETECTRANGE;

    return newAI;
}

void DataReceivingSystem::createProjectileClient(Vector3 entityPos,int weaponindex, EntityID ownerID, int direction, unsigned long long ID) //add clockcomponent that has a clock inside
{
        EntityID id = _em->CreateNewEntity();
        _em->Assign<ServerEntityID>(id, ServerEntityID{ID});
        //register this entity as the player for this client
        _em->Assign<EntityModelType>(id, EntityModelType{RL::ModelType::PROJECTILE});
        if (direction == 1)
            _em->Assign<Owner>(id, Owner{ownerID, RL::ModelType::ENNEMY});
        else if (direction == -1)
            _em->Assign<Owner>(id, Owner{ownerID, RL::ModelType::SPACESHIP});
        _em->Assign<IsAlive>(id, IsAlive{true});
        _em->Assign<ModelName>(id, ModelName{_assetManager->getProjectileModels().at(weaponindex)->getName(),_assetManager->getSpecificDrawableWithType(_assetManager->getProjectileModels().at(weaponindex)->getName(), RL::ModelType::PROJECTILE)->getExplosionName()});
        _em->Assign<ModelScale>(id, ModelScale{_assetManager->getSpecificDrawableWithType(_assetManager->getProjectileModels().at(weaponindex)->getName(), RL::ModelType::PROJECTILE)->getScale()});
        _em->Assign<PitchYawRoll>(id, PitchYawRoll{0.0f, 0.0f, 0.0f});
        _em->Assign<Collider>(id, Collider{BoundingBox{}});


        _em->Assign<Position>(id, {entityPos.x,
                                   entityPos.y,
                                   entityPos.z });
        _em->Assign<Velocity>(id, {0.0f,
                                   0.0f,
                                   _assetManager->getSpecificDrawableWithType(_assetManager->getProjectileModels().at(weaponindex)->getName(), RL::ModelType::PROJECTILE)->getVelocity().z}); // very important  x - OWNERTYPE to change de direction of the bullet, to do in movement system if entity is projectile

        _em->Assign<Hp>(id, Hp{_assetManager->getSpecificDrawableWithType(_assetManager->getProjectileModels().at(weaponindex)->getName(), RL::ModelType::PROJECTILE)->getHp()});
        _em->Assign<ServerEntityID>(id, ServerEntityID{ID});
        // _em->Assign<ProjectileWeapon>(id, ProjectileWeapon{weaponSet->weapons.at(weaponSet->currentWeapon)});

        //play sound of specific weapon being fired, to add in csv the sound name :)

}

void DataReceivingSystem::create_lootClient(Vector3 pos, std::string lootName, unsigned long long ID)
{
    EntityID id = _em->CreateNewEntity();

    _em->Assign<ServerEntityID>(id, ServerEntityID{ID});

    _em->Assign<EntityModelType>(id, EntityModelType{RL::ModelType::POWERUP});
    _em->Assign<Owner>(id, Owner{id, RL::ModelType::MCGUYVER});
    _em->Assign<IsAlive>(id, IsAlive{true});
    _em->Assign<ModelName>(id, ModelName{lootName,lootName});
    _em->Assign<ModelScale>(id, ModelScale{_assetManager->getSpecificDrawableWithType(lootName, RL::ModelType::POWERUP)->getScale()});
    _em->Assign<Position>(id, Position{pos});
    _em->Assign<PitchYawRoll>(id, PitchYawRoll{0.0f, 0.0f, 0.0f});
    _em->Assign<ModelDimensions>(id, ModelDimensions{_assetManager->getSpecificDrawableWithType(lootName, RL::ModelType::POWERUP)->getWidth(),
                                                                _assetManager->getSpecificDrawableWithType(lootName, RL::ModelType::POWERUP)->getHeight(),
                                                                _assetManager->getSpecificDrawableWithType(lootName, RL::ModelType::POWERUP)->getLength()});
    _em->Assign<Collider>(id, Collider{BoundingBox{}});
    _em->Assign<Velocity>(id, Velocity{0.0f, 0.0f, 0.1f});
    _em->Assign<Timer>(id, Timer{std::chrono::system_clock::now(), 12});
    if (_assetManager->getSpecificDrawableWithType(lootName, RL::ModelType::POWERUP)->getStyle() == "projectile") {
        _em->Assign<Loot>(id, Loot{true,generateWeaponLootClient(lootName), Shield{20, false}});
        _em->Assign<PowerUpType>(id, PowerUpType{PowerUpEnum::WEAPONPOWER});
    }
    if (_assetManager->getSpecificDrawableWithType(lootName, RL::ModelType::POWERUP)->getStyle() == "shield") {
        _em->Assign<Shield>(id, generateShieldLootClient());
        _em->Assign<PowerUpType>(id, PowerUpType{PowerUpEnum::SHIELDPOWER});
    }
    _em->Assign<ServerEntityID>(id, ServerEntityID{ID});
}

ProjectileWeapon DataReceivingSystem::generateWeaponLootClient(std::string projectileName)
{
    ProjectileWeapon BaseWeapon;
    Vector3 Vel;
    BaseWeapon.name = projectileName;
    BaseWeapon.modelName = projectileName;
    BaseWeapon.maxAmmo = 999; // max amom is 999
    BaseWeapon.curAmmo = 100; // set ammo per loot to 50? 
    BaseWeapon.splash = 0.0f; //TODO : add in projectile CSV and in drawable 3d class and constructor and in asset manager loadProjectiles models
    BaseWeapon.range = 50.0f; // TODO: same as above
    BaseWeapon.cooldowninseconds = _assetManager->getSpecificDrawableWithType(BaseWeapon.modelName, RL::ModelType::PROJECTILE)->getShootCD();
    BaseWeapon.damage = _assetManager->getSpecificDrawableWithType(BaseWeapon.modelName, RL::ModelType::PROJECTILE)->getHp();
    Vel = _assetManager->getSpecificDrawableWithType(BaseWeapon.modelName, RL::ModelType::PROJECTILE)->getVelocity();
    BaseWeapon.vel = {Vel.x, Vel.y, Vel.z};
    BaseWeapon.lasttimeweaponwasshot = std::chrono::system_clock::now();

    return BaseWeapon;
}

Shield DataReceivingSystem::generateShieldLootClient()
{
    Shield ShieldLoot;

    ShieldLoot.shield = 20;
    ShieldLoot.shieldActive = false;
    return ShieldLoot;
}

void DataReceivingSystem::create_explosion(Vector3 pos, std::string exploName, unsigned long long ID)
{
    EntityID id = _em->CreateNewEntity();
    _em->Assign<ServerEntityID>(id, ServerEntityID{ID});
    
    _em->Assign<EntityModelType>(id, EntityModelType{RL::ModelType::EXPLOSION});
    _em->Assign<Owner>(id, Owner{id, RL::ModelType::EXPLOSION});
    _em->Assign<IsAlive>(id, IsAlive{true});
    _em->Assign<ModelName>(id, ModelName{exploName,exploName});
    _em->Assign<ModelScale>(id, ModelScale{_assetManager->getSpecificDrawableWithType(exploName, RL::ModelType::EXPLOSION)->getScale()});
    _em->Assign<Position>(id, Position{pos});
    _em->Assign<PitchYawRoll>(id, PitchYawRoll{0.0f, 0.0f, 0.0f});
    _em->Assign<AnimationData>(id, AnimationData{0, 0});
    _em->Assign<ServerEntityID>(id, ServerEntityID{ID});
}


std::vector<ProjectileWeapon> DataReceivingSystem::generateStartWeaponset(std::string modelName)
{
    std::vector<ProjectileWeapon> startWeaponset;

    ProjectileWeapon BaseWeapon;
    Vector3 Vel;

    BaseWeapon.name = modelName;
    BaseWeapon.modelName = modelName;
    BaseWeapon.maxAmmo = -999; // unlimitted ammo stock
    BaseWeapon.curAmmo = -999; // unlimitted ammo, both the -999 are for unlimited should define it later
    BaseWeapon.splash = 0.0f; //TODO : add in projectile CSV and in drawable 3d class and constructor and in asset manager loadProjectiles models
    BaseWeapon.range = 50.0f; // TODO: same as above
    BaseWeapon.cooldowninseconds = _assetManager->getSpecificDrawableWithType(BaseWeapon.modelName, RL::ModelType::PROJECTILE)->getShootCD();
    BaseWeapon.damage = _assetManager->getSpecificDrawableWithType(BaseWeapon.modelName, RL::ModelType::PROJECTILE)->getHp();
    Vel = _assetManager->getSpecificDrawableWithType(BaseWeapon.modelName, RL::ModelType::PROJECTILE)->getVelocity();
    BaseWeapon.vel = {Vel.x, Vel.y, Vel.z};
    BaseWeapon.lasttimeweaponwasshot = std::chrono::system_clock::now();

    startWeaponset.push_back(BaseWeapon);
    return startWeaponset;
}


void DataReceivingSystem::createPlayerClient(std::string modelName, unsigned long long ID, unsigned long long clientHashID) // here we will add base weapon choice, avatar choice as well chosen by user in menu, the avatar is just cosmetic
{
    EntityID id = _em->CreateNewEntity();
    //register this entity as the player for this client
    std::vector<int> playerInput;
    Vector3 Vel;

    _em->Assign<ServerEntityID>(id, ServerEntityID{clientHashID});

    _em->Assign<EntityModelType>(id, EntityModelType{RL::ModelType::SPACESHIP});
    _em->Assign<Owner>(id, Owner{clientHashID, RL::ModelType::MCGUYVER});
    std::cout << "OWNER ID CREATE PLAYER " << id << " with Owner " << clientHashID << std::endl;

    _em->Assign<UIAvatarNames>(id, UIAvatarNames{modelName});
    
    _em->Assign<ModelName>(id, ModelName{modelName,_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::SPACESHIP)->getExplosionName()});
    _em->Assign<ModelScale>(id, ModelScale{_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::SPACESHIP)->getScale()});
    _em->Assign<ModelDimensions>(id, ModelDimensions{_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::SPACESHIP)->getWidth(),
                                                                _assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::SPACESHIP)->getHeight(),
                                                                _assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::SPACESHIP)->getLength()});
    _em->Assign<PitchYawRoll>(id, PitchYawRoll{0.0f, 0.0f, 0.0f});
    _em->Assign<Collider>(id, Collider{BoundingBox{}});
    _em->Assign<Input>(id, Input{playerInput});
    
    _em->Assign<IsAlive>(id, IsAlive{true});
    _em->Assign<Position>(id, _playerStartingPos);
    Vel = _assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::SPACESHIP)->getVelocity();
    _em->Assign<Velocity>(id, Velocity{Vel.x, Vel.y, Vel.z});
    _em->Assign<Score>(id, Score{0});
    _em->Assign<Hp>(id, Hp{_assetManager->getSpecificDrawableWithType(modelName, RL::ModelType::SPACESHIP)->getHp()});
    _em->Assign<Shield>(id, Shield{100});

    //here we have to assign an Arsenal ( the weapons he has), an arsenal is a struct containing a vector of 3 weapon structs
    _em->Assign<Weaponset>(id, Weaponset{generateStartWeaponset("orangeLight"), 0}); //to be changed along with the constructor of this function to refelect the player choice of starting weapon
    //mock extra weapon for ui testing to delete later
}
